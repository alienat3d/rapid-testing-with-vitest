import { expect, test } from 'vitest';
import { deepMerge } from '../src';

// * 4.0 Теперь можно поработать и с более сложным глубоким слиянием объектов. Просто скопируем код из [deep-merge\test\shallowMerge.test.ts] и чуть изменим его. Мы поместим свойства "github" & "twitter" на уровень ниже в другое свойство с объектом. И ожидать в "expect" мы будем, что не смотря на это они оба попадут в итоговый объект в свойство "accounts".
// Go to [deep-merge\src\index.ts]
// ? 4.2 Мы можем добавить "skip" после "test", чтобы пока пропустить выполнение этого теста, чтобы убедиться, что наша работа по рефакторингу в [deep-merge\src\index.ts] не нарушила предыдущие тесты.
// 4.3 Итак, мы убедились, что наше присвоение значений "вручную" при помощи цикла "for of" работает также, как было с использованием метода "for of". И теперь в наших руках больше контроля над тем как мы можем производить слияние двух вложенных свойств.
// Go to [deep-merge\src\index.ts]
test('deep merge with props overlaps', () => {
  const merged = deepMerge(
    {
      name: 'Al',
      accounts: {
        github: 'alienat3d',
      },
    },
    {
      accounts: {
        twitter: 'alienat3d',
      },
    }
  );

  expect(merged).toEqual({
    name: 'Al',
    accounts: {
      github: 'alienat3d',
      twitter: 'alienat3d',
    },
  });
});

// * 5.0 Но помимо ожидаемого использования нашего функционала было бы здорово протестировать путь, который заставит функцию выкинуть ошибки, которые мы ожидаем. Т.о. мы снизим шансы, что функция провалится втихую с неизвестным результатом на проде. Добавим тест, чтобы убедиться, что появится определённая ошибка при попытки слияния данных разных типов.
// 5.1 Один из способов указать, что мы делаем тест с ожиданием возникновения ошибки это добавление "fails" модификатора после "test". Другими словами, что пройти этот тест функция должна выкинуть ошибку. Однако стоит помнить об опасности такого подхода, т.к. он не определяет какая и когда ошибка происходит. Чтобы иметь больше управления над ошибками воспользуемся иным подходом.
// 5.2 Мы используем "toThrowError" метод у "expect". Стоит обратить внимание на то, что "deepMerge" теперь следует обернуть в коллбэк-функцию, чтобы тест прошёл.
// 5.3 Теперь мы можем добавить сообщение для вывода ошибки в "toThrowError".
// Go to [deep-merge\src\index.ts]
// test.fails('throws errors on merging two different types', () => {
test('throws errors on merging two different types', () => {
  expect(() =>
    deepMerge(['foo', 'bar'], { foo: 'bar' }).toThrowError(
      'Error: Can not merge two different types.'
    )
  );
});

// * 6.0 Что такое «snapshot»? Это полезная функция Vitest, которая даёт возможность удостовериться, что результат функции неожиданно не сменится, путём сравнивая текущий результат с прошлым. Для этого используется метод "toMatchSnapshot". Преобразуем один из прошлых тестов для использования со снэпшотом.
// 6.1 Теперь, когда запустим тестирование, то увидим, что создалась отдельная папка "__snapshots__" и файл-снэпшот в ней, в котором записался результат работы функции "deepMerge". Необходимо его просмотреть, удовлетворяет ли нас результат, который в нём отпечатался. Снэпшоты освобождают нас от постоянного копирования ожидаемого результата работы функции, когда мы проводим массу тестов на одну и ту же функцию, где ожидаем один и тот же результат.
// * 7.0 На прошлом уроке мы научились работать со снэпшотами, с помощью которых удобно следить, что после внесения изменений в функцию результат её работы останется неизменным. Но порой мы хотим, чтобы этот результат после изменения функции изменился. Или мы можем изменить вводные данные для охвата разных сценариев и тогда нам нужно будет обновить также снэпшот соответственно. Рассмотрим два способа сделать это.
test('deep merge with props overlaps', () => {
  const merged = deepMerge(
    {
      name: 'Al',
      accounts: {
        github: 'alienat3d',
      },
    },
    {
      accounts: {
        twitter: 'alienat3d',
      },
    }
  );

  expect(merged).toMatchSnapshot();
});
