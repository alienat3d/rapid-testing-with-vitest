// 3.4 В самой же функции "deepMerge" мы используем для слияния двух объектов встроенный в JS метод объектов "assign".
// Go to [deep-merge\test\merge.test.ts]
// 3.7 Итак, добавим условие, чтобы проверить, является ли аргумент "a" массивом. И если является, то с помощью spread-оператора мы развернём содержимое первого и второго аргумента-массива в итоговый массив.
// 4.1 Теперь мы встречаем ошибку, это из-за того, что метод "assign" способен на поверхностное слияние, т.е. на верхнем уровне вложенности. Но мы можем сделать, что называется "shadow clone" объекта "a", а зачем пройтись по всем ключам объекта "b", используя цикл "for of". Чтобы получить предыдущее поведение мы могли бы напрямую присвоить значения объекта "b" итоговому "merged" объекту.
// Go to [deep-merge\test\deepMerge.test.ts]
// 4.4 Улучшим нашу реализацию, чтобы пройти также тест на глубокое слияние свойств объекта. Мы используем рекурсию здесь для вложенных в объекты свойств.
// 4.5 Отлично, тесты снова пройдены. Теперь у нас есть готовая функция для глубокого слияния двух объектов или массивов.
// Go to [deep-merge\test\deepMerge.test.ts]
// 5.4 Добавим ещё одну проверку для корректного вывода ошибки с помощью конструкта "throw new Error", в случае, если была зафиксирована попытка слияния разных типов данных.
export function deepMerge(a, b) {
  if (Array.isArray(a) && Array.isArray(b)) {
    return [...a, ...b];
  }
  if (Array.isArray(a) || Array.isArray(b) || typeof a !== typeof b) {
    throw new Error('Can not merge two different types.');
  }
  // return Object.assign(a, b);
  const merged = { ...a };

  for (const key of Object.keys(b)) {
    if (typeof a[key] === 'object' || Array.isArray(a[key])) {
      merged[key] = deepMerge(a[key], b[key]);
    } else merged[key] = b[key];
  }

  return merged;
}
